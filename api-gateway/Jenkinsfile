pipeline {
    // Usa un agente con Docker y Kubectl. 'docker && k8s' son etiquetas
    // que deber√≠as haber puesto en tu agente configurado. Si no, usa 'agent any'
    // pero aseg√∫rate de que tiene Docker y kubectl.
    agent any

    environment {
        DOCKERHUB_USERNAME = 'juansmc' // Reemplaza con tu nombre de usuario de Docker Hub

        // Use SERVICE_NAME consistently for the microservice being deployed
        SERVICE_NAME = 'api-gateway'

        IMAGE_NAME = "${DOCKERHUB_USERNAME}/api-gateway-ecommerce-boot" // Tu nombre de imagen
        IMAGE_TAG = "dev-${env.BUILD_NUMBER}" // Etiqueta din√°mica: dev-<numero_build>
        KUBE_NAMESPACE = 'development'
        DOCKER_CREDENTIALS_ID = 'dockerhub-creds'

        // This is the crucial part for the path:
        KUBE_MANIFESTS_DIR = 'k8s' // Path from the project root to your k8s directory

        // Construct the full paths to the specific Kubernetes files
        KUBE_DEPLOYMENT_FILE = "${KUBE_MANIFESTS_DIR}/${SERVICE_NAME}-container-deployment.yaml"
        // Assuming your service.yml is also in the k8s directory
        KUBE_SERVICE_FILE = "${KUBE_MANIFESTS_DIR}/${SERVICE_NAME}-service.yaml" // Corrected path and typical naming convention
    }

    stages {
        stage('1. Checkout') {
            steps {
                echo "Clonando el repositorio..."
                checkout scm
                echo "Checkout completado para la rama: ${env.BRANCH_NAME}"
            }
        }

        stage('2. Build & Package üõ†Ô∏è') {
            steps {
                echo "Construyendo el proyecto ${env.SERVICE_NAME} con Maven..."
                // Assuming your pom.xml for api-gateway is in the 'api-gateway' subdirectory
                // If it's in the root, remove the 'dir' block.
                dir("${env.SERVICE_NAME}") { // Navigate into the service directory
                    sh 'mvn clean package -DskipTests'
                }
            }
        }

        stage('3. Build & Push Docker Image üê≥') {
            steps {
                // *** FIX: Wrap the docker.withRegistry block in a script block ***
                script { // <--- ADD THIS LINE
                    echo "Construyendo y subiendo la imagen: ${env.IMAGE_NAME}:${env.IMAGE_TAG}"
                    // Usamos docker.withRegistry para manejar login/logout autom√°ticamente
                    docker.withRegistry('https://registry.hub.docker.com', env.DOCKER_CREDENTIALS_ID) {
                        // Build the image from the service directory where the Dockerfile should be
                        // Assuming Dockerfile is at api-gateway/Dockerfile
                        def customImage = docker.build("${env.IMAGE_NAME}:${env.IMAGE_TAG}", "-f ${env.SERVICE_NAME}/Dockerfile ${env.SERVICE_NAME}")

                        // Sube la imagen (push)
                        customImage.push()
                    }
                    echo "Imagen subida exitosamente."
                } // <--- AND THIS LINE
            }
        }

        stage('4. Update K8s Manifests') {
            steps {
                echo "Actualizando la imagen en ${env.KUBE_DEPLOYMENT_FILE}..."
                // 'sh' commands are generally allowed directly, but if you have
                // any complex Groovy logic here, it might also need a 'script' block.
                sh "sed -i 's|image: .*|image: ${env.IMAGE_NAME}:${env.IMAGE_TAG}|g' ${env.KUBE_DEPLOYMENT_FILE}"
                echo "Manifest actualizado:"
                sh "cat ${env.KUBE_DEPLOYMENT_FILE}"
            }
        }

        stage('5. Deploy to Dev K8s üöÄ') {
            steps {
                echo "Desplegando ${env.SERVICE_NAME} en Kubernetes (Namespace: ${env.KUBE_NAMESPACE})..."
                // 'sh' commands are generally allowed directly.
                sh "kubectl apply -f ${env.KUBE_SERVICE_FILE} -n ${env.KUBE_NAMESPACE}"
                sh "kubectl apply -f ${env.KUBE_DEPLOYMENT_FILE} -n ${env.KUBE_NAMESPACE}"
                echo "Esperando que el despliegue se complete..."
                sh "kubectl rollout status deployment/${env.SERVICE_NAME}-container -n ${env.KUBE_NAMESPACE} --timeout=120s"
                echo "¬°Despliegue completado!"
            }
        }
    }

    post {
        always {
            echo 'Limpiando el workspace...'
            cleanWs() // Limpia el workspace despu√©s de cada build
        }
        success {
            echo '¬°El pipeline se ejecut√≥ exitosamente!'
            // Aqu√≠ podr√≠as enviar notificaciones (Slack, Email)
        }
        failure {
            echo '¬°El pipeline fall√≥!'
            // Enviar notificaciones de fallo
        }
    }
}